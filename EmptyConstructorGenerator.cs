using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;



namespace EmptyConstructor;

[System.AttributeUsage(System.AttributeTargets.Class)]
public class EmptyConstructorAttribute : System.Attribute
{
}

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class EmptyConstructorGenerator : IIncrementalGenerator
{
    private const string AttributeName = "EmptyConstructor.EmptyConstructorAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {

        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        IncrementalValuesProvider<ClassDeclarationSyntax> provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => ctx)
            .Where(ctx => ShouldInclude(ctx, (ClassDeclarationSyntax) ctx.Node))
            .Select(((syntaxContext, _) => (ClassDeclarationSyntax) syntaxContext.Node));
 
        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    private bool HasAttribute(GeneratorSyntaxContext context, MemberDeclarationSyntax classDeclarationSyntax)
    {
        foreach (AttributeSyntax? attributeSyntax in classDeclarationSyntax.AttributeLists.SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {

            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
            {
                continue; // if we can't get the symbol, ignore it
            }

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();
            bool hasAttribute = attributeName.Contains(AttributeName);

            if (hasAttribute)
            {
                return true;
            }
        }

        return false;
    }

    private bool ShouldInclude(GeneratorSyntaxContext context, BaseTypeDeclarationSyntax classDeclarationSyntax)
    {
        return HasAttribute(context, classDeclarationSyntax);
    }

    
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        foreach (ClassDeclarationSyntax? classDeclarationSyntax in classDeclarations)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var className = classDeclarationSyntax.Identifier.Text;

            bool hasEmptyConstructor = classSymbol.Constructors.Any(x => x.Parameters.IsEmpty);
            if (hasEmptyConstructor)
            {
                continue;
            }
            
            var code = $$"""
                         // <auto-generated/>

                         namespace {{namespaceName}};

                         partial class {{className}}
                         {
                             public {{className}}()
                             {
                             }
                         }

                         """;

            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}